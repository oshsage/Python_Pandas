# DFS & BFS

### 1. 스택 자료구조

- 먼저 들어 온 데이터가 나중에 나가는 형식의 자료구조: 선입후출

- 입구와 출구가 동일한 형태로 스택을 시각화

- 박스를 쌓고 박스를 빼는 모습을 상상

- 스택 구현은 리스트를 이용

```python
stack = []

stack.append(5)
stack.append(2)
stack.append(3)
stack.append(7)
stack.pop()         # 리스트의 맨 마지막 요소를 돌려주고 그 요소를 삭제 (가장 나중에 드러온 7이 삭제)
stack.append(1)
stack.append(4)
stack.pop()         # 가장 최근 숫자 4가 삭제

print(stack[::-1])  # 최상단 원소부터 출력
print(stack)        # 최하단 원소부터 출력
```



  

### 2. 큐 자료구조

- 먼저 들어 온 데이터가 먼저 나가는 형식의 자료구조: 선입선출

- 큐는 입구와 출구가 모두 뚫려있는 `터널` 이라고 생각

- collection `deque` 를 import해여 구조를 사용

  

### 3. 재귀 함수

- 재귀함수(Recursive Function)란 `자기 자신을 대시 호출하는 함수`
- 재귀 함수 예제
  - '재귀 함수를 호출합니다.' 라는 문자열을 무한히 출력
  - 어느 정도 출력하다가 최대 재귀 깊이 초과 메시지가 출력

```python
def recursive_function():
    print('재귀 함수를 호출합니다.')
    recursive_function()

recursive_function()
```



- 재귀 함수의 종료 조건
  - 재귀 함수를 문제 풀이에서 사용할 때는 재귀 함수의 종료 조건을 반드시 명시해야 함
  - 종료 조건을 제대로 명시하지 않으면 함수가 무한히 호출됨

```python
def recursive_function(i):
    # 100번째 호출으 했을 때 종료되도록 종료 조건 명시
    if i == 100:
        return
    print(i, '번째 재귀함수에서', i+1, '번째 재귀함수를 호출합니다.')
    recursive_function(i+1)
    print(i, '번째 재귀함수를 종료합니다.')         # 스택 자료처럼 가장 나중에 출력 i를 기준으로 프린트 출력

recursive_function(1)
```



- 팩토리얼 구현 예제

`n! = 1 x 2 x 3 x ... x (n - 1) x n` 

```python
def factorial_recursive(n):
    if n <= 1:
        return 1
    return n * factorial_recursive(n);

print('반복적으로 구현:', factorial_recursive(5))		# 출력값 120
```



- 최대공약수 계산 예제

  - 풀이방법: 유클리드 호제법

    - 두 자연수 A, B에 대하여 (A>B) A를 B로 나눈 나머지를 R이라고 하자.
    - 이때 A와 B의 최대공약수는 B와 R의 최대공약수와 같다.

  - 유클리드 호제법을 아이디어로 재귀 함수를 구성

    ![image-20201024141127712](C:\Users\oh12s\AppData\Roaming\Typora\typora-user-images\image-20201024141127712.png)

```python
def gcd(a, b):
    if a % b == 0:
        return b
    else:
        return gcd(b,a % b)
print(gcd(192,162))
```



- 모든 재귀함수는 반복문을 이용해 동일한 기능을 구현할 수 있다.
- 재귀함수가 반복문보다 유리한 경우도 있고 불리한 경우도 있기에 문제를 통해 경험치를 쌓자.
- 컴퓨터가 함수를 연속적으로 호출하면 컴퓨터 메모리 내부의 스택 프레임에 쌓이므로, 스택을 사용해야 할 때 구현상 스택 라이브러리 대신에 재귀함수를 이용하는 경우가 많다.



드디어..



## DFS(Depth-First Search)

- `깊이 우선 탐색`이라고도 부르며 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘

- DFS 스택 자료구조(혹은 재귀 함수)를 이용한다.

  - 탐색 시작 노드를 스택에 삽입하고 방문 처리

  - 스택의 최상단 노드에 방문하지 않은 인접한 노드가 하나라도 있으면 그 노드를 스택에 넣고 방문처리한다. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다.

  - 더 이상 2번의 과정을 수행할 수 없을 때까지 반복

  - 방문 기준은 번호가 낮은 인접노드부터! (어디까지나 가정. 내맘대로 할 수 있다.)

    1) 그래프를 준비한다

    <img src="C:\Users\oh12s\AppData\Roaming\Typora\typora-user-images\image-20201024142905202.png" alt="image-20201024142905202" style="zoom:80%;" />

    2) 시작 노드인 '1'을 스택에 삽입하고 방문처리

    3) 스택의 최상단 노드인 '1' 에 방문하지 않은 인접 노드 '2', '3', '8' 이 있습니다.

    이 중에서 가장 작은 노드인 '2' 를 스택에 넣고 방문 처리

    4) 스택의 최상단 노드인 '2'에 방문하지 않은 인접 노드 '7'이 있습니다.

    따라서 '7'번 노드를 스택에 넣고 방문처리

    5) 스택의 최상단 노드인 '7'에 방문하지 않은 인접 노드 '6', '8' 이 있습니다.

    이 중에서 가장 작은 노드인 '6'을 스택에 넣고 방문 처리

    6) 스택의 최상단 노드인 '6'에 방문하지 않은 인접 노드가 없습니다.

    따라서 스택에서 '6'번 노드를 꺼냅니다.(중요)

    7) 스택의 최상단 노드인 '7'에 방문하지 않은 인접 노드 '8' 이 있습니다.

    따라서 '8' 번 노드를 스택에 넣고 방문 처리

    8) 이러한 과정을 반복하여 전체 노드를 탐색

```python
# DFS 소스코드 예제

# DFS 메서드 정의
def dfs(graph, v, visited):
    visited[v] = True                   # v번 노드에 방문했습니다.
    print(v, end =' ')                  # 방문했다고 출력
    for i in graph[v]:                  # graph[v]는 v번 노드와 인접한 노드배열을 의미
        if not visited[i]:              # if not 조건: 조건이 거짓일 때 수행. 예를 들어 visited[2]가 False이면 밑에 dfs 함수 실행
            dfs(graph, i, visited)      # 해석하면  v번 노드와 인접한 노드중 가장 작은 수의 노드가 거짓(False = 방문 x)이라면 dfs 함수 실행(
                                        # 방문하지 않았은 노드를 방문하겠다라는 의미

# 각 노드가 연결된 정보를 표현(2차원 리스트)
graph = [
    [],             # 배열의 첫번째가 0부터 시작하기 때문에 1번노드가 배열[1]이 1번노드가 될수 있게 배열[0]을 비워놓는다.
    [2, 3, 8],      # 1번 노드의 인접 노드들
    [1, 7 ],        # 2번 노드의 인접 노드들
    [1, 4, 5],      # 3번 노드의 인접 노드들
    [3, 5],         # 4번 노드의 인접 노드들
    [3, 4],         # 5번 노드의 인접 노드들
    [7],            # 6번 노드의 인접 노드들
    [2, 6, 8],      # 7번 노드의 인접 노드들
    [1, 7],         # 8번 노드의 인접 노드들
]

# 각 노드가 방문된 정보를 표현 (1차원 리스트)
visited = [False] * 9

# 정의된 DFS 함수 호출
dfs(graph, 1, visited)
```



## BFS(Breadth-First Search)

- 너비 우선 탐색이라고도 부르며, 그래프에서 가까운 노드부터 우선적으로 탐색하는 알고리즘

- `큐 자료구조`를 이용

  - 탐색 시작 노드를 큐에 삽입하고 방문 처리

  - 큐에서 노드를 꺼낸 뒤에 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문처리

  - 더 이상 2번의 과정을 수행할 수 없을 때까지 반복.

    1) 그래프를 준비한다. (방문 기준: 번호가 낮은 인접 노드부터)

<img src="C:\Users\oh12s\AppData\Roaming\Typora\typora-user-images\image-20201024151915260.png" alt="image-20201024151915260" style="zoom: 67%;" />

​				2) 시작 노드인 '1' 을 큐에 삽입하고 방문처리

​				3) 큐에서 노드 '1'을 꺼내 방문하지 않은 인접 노드 '2', '3', '8' 을 큐에 삽입하고 방문처리

​				4) 큐에서 노드 '2'를 꺼내 방문하지 않은 인접 노드 '7'을 큐에 삽입하고 방문처리

​				5) 큐에서 노드 '3' 을 꺼내 방문하지 않은 인접 노드 '4', '5'을 큐에 삽입하고 방문처리

​				6) 큐에서 노드 '8' 을 꺼내고 방문하지 않은 인접 노드가 없으므로 무시한다.

​				7) 이러한 과정을 반복하여 전체 노드의 탐색.

```python
# BFS 소스코드 예제

# from collections import deque (위에 코드에서 이미 써서 여긴 주석처리함)

def bfs(graph, start, visited):
    queue = deque([start])                  # 큐 구현을 위해 deque 라이브러리 사용
    visited[start] = True                   # 현재 노드를 방문 처리
    while queue:                            # 큐가 빌 때까지 반복
        v =queue.popleft()                  # 현재 노드를 꺼내고 v에 저장 (한 바퀴 돌았을 때부터는 i번 노드를 꺼내어 v에 저장했다고 보면 되겠지?)
        print(v, end = ' ')                 # 출력
        for i in graph[v]:                  # v번 노드와 인접한 노드배열 중 가장 작은수 부터 방문하러
            if not visited[i]:              # v번과 인접한 노드 i가 거짓(False = 방문 x)이라면
                queue.append(i)             # 큐에 해당 노드를 추가
                visited[i] = True           # i번 노드 방문 처리

# 각 노드가 연결된 정보를 표현(2차원 리스트)
graph = [
    [],             # 배열의 첫번째가 0부터 시작하기 때문에 1번노드가 배열[1]이 1번노드가 될수 있게 배열[0]을 비워놓는다.
    [2, 3, 8],      # 1번 노드의 인접 노드들
    [1, 7 ],        # 2번 노드의 인접 노드들
    [1, 4, 5],      # 3번 노드의 인접 노드들
    [3, 5],         # 4번 노드의 인접 노드들
    [3, 4],         # 5번 노드의 인접 노드들
    [7],            # 6번 노드의 인접 노드들
    [2, 6, 8],      # 7번 노드의 인접 노드들
    [1, 7],         # 8번 노드의 인접 노드들
]

# 각 노드가 방문된 정보를 표현 (1차원 리스트)
visited = [False] * 9

# 정의된 DFS 함수 호출
dfs(graph, 1, visited)          # 출력값 1 2 3 8 7 4 5 6
```



## 음료수 얼려먹기

- 첫 번째 줄에 얼음 틀의 세로길이 N과 가로 길이 M이 주어집니다.

- 두 번째 줄부터 N+1번째 줄까지 얼음 틀의 형태가 주어집니다.

- 이때 구멍이 뚫려있는 부분은 0, 그렇지 않은 부분은 1입니다.

- 한번에 만들 수 있는 아이스크림의 개수를 출력

```python
# 입력예시
4 5
00110
00011
11111
00000
# 출력 예시
3
```


















